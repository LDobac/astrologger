<!DOCTYPE html><html><head><link rel="sitemap" href="/sitemap-index.xml"><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Astro v3.0.12"><meta name="description" content="LEETCODE - 23. MERGE K SORTED LISTS  문제 - LeetCode - 23. Merge k Sorted Lists [https://leetcode.com/problems/merge-k-sorted-lists/]   문제 설명  지난 LeetCode - 21. Merge Two Sorted Lists [https://jaehee.dev/#/post/22] 문제의 확장 버전입니다.  정렬"><meta name="author" content="jaehee"><meta property="og:url" content="https://jaehee.dev/posts/leetcode---23-merge-k-sorted-lists/"><meta property="og:type" content="website"><meta property="og:title" content="LeetCode - 23. Merge k Sorted Lists"><meta property="og:description" content="LEETCODE - 23. MERGE K SORTED LISTS  문제 - LeetCode - 23. Merge k Sorted Lists [https://leetcode.com/problems/merge-k-sorted-lists/]   문제 설명  지난 LeetCode - 21. Merge Two Sorted Lists [https://jaehee.dev/#/post/22] 문제의 확장 버전입니다.  정렬"><meta property="og:image" content="https://jaehee.dev/posts/leetcode---23-merge-k-sorted-lists.png"><meta property="og:image:alt" content="Thumbnail of LeetCode - 23. Merge k Sorted Lists"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-BLG37NTK4J"></script><script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());

                gtag('config', 'G-BLG37NTK4J');
            </script><!-- Naver Search Advisor --><meta name="naver-site-verification" content="6d6d37b7cb8c33fa22601afa3a994e0526b4a43f"><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"><title>LeetCode - 23. Merge k Sorted Lists</title><link rel="stylesheet" href="/asset_dir/index.7d0fd359.css" />
<link rel="stylesheet" href="/asset_dir/index.accceb83.css" /></head><body class="w-full"><header class="flex flex-col w-full justify-center items-center mt-6"><a href="/"><img src="/asset_dir/profile_image.bd953236_Z1mQw6L.webp" class="rounded-full w-28" alt="Profile image with cat" width="200" height="200" loading="lazy" decoding="async"><p class="mt-1 text-3xl font-bold hover:text-sky-300">Jaehee</p></a><p class="mt-1">Hi!</p><nav class="container border-y py-4 mt-6"><ul class="w-full flex justify-between px-6 font-bold"><li class="hover:text-sky-300"><a href="/posts/1">Posts</a></li><li class="hover:text-sky-300"><a href="/portfolio">Portfolio</a></li><li class="hover:text-sky-300"><a href="https://github.com/LDobac">Github</a></li><li class="hover:text-sky-300"><a href="https://www.instagram.com/jaehee24_/">Instagram</a></li></ul></nav></header><main class="container my-6 px-4 mx-auto xl:p-0"><div class=""><header class="flex flex-col space-y-4 border-b-2 border-sky-300 pb-6"><img src="/posts/leetcode---23-merge-k-sorted-lists.png" class="w-full bg-black" alt="Thumbnail of LeetCode - 23. Merge k Sorted Lists" width="1200" height="630" loading="lazy" decoding="async"><h1 class="leading-none"><span class="block text-2xl font-bold">LeetCode - 23. Merge k Sorted Lists</span><a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a></h1><div class="flex flex-row flex-wrap w-full gap-3"><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leet-code/1"><span>Leet Code</span></a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/hard/1"><span>hard</span></a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/cpp/1"><span>cpp</span></a></div><p><span>2021년 12월 08일</span></p></header><article class="mt-6 border-b-2 border-sky-300 pb-6"><div class="markdown-body"><h2 id="leetcode---23-merge-k-sorted-lists">LeetCode - 23. Merge k Sorted Lists</h2>
<p>문제 - <a href="https://leetcode.com/problems/merge-k-sorted-lists/">LeetCode - 23. Merge k Sorted Lists</a></p>
<h2 id="문제-설명">문제 설명</h2>
<p>지난 <a href="https://jaehee.dev/#/post/22">LeetCode - 21. Merge Two Sorted Lists</a> 문제의 확장 버전입니다.</p>
<p>정렬된 k개의 연결 리스트가 입력되면 모든 연결 리스트를 정렬된 하나의 연결리스트 반환합니다.</p>
<p>난이도는 <code>HARD</code> 난이도 입니다.</p>
<h2 id="풀이">풀이</h2>
<p><a href="https://github.com/LDobac/leetcode/tree/master/23.%20Merge%20k%20Sorted%20Lists">My Solutions(Github)</a></p>
<h3 id="solution-1---merge-one-by-one">Solution 1 - Merge one by one</h3>
<p>첫 번째 해결 방법은 <a href="https://jaehee.dev/#/post/22">LeetCode - 21. Merge Two Sorted Lists</a>의 풀이 방법을 그대로 사용하여 풀어보겠습니다.</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeKLists</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">vector</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8">></span><span style="color: #F97583">&#x26;</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">lists</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (lists.</span><span style="color: #B392F0">size</span><span style="color: #E1E4E8">() </span><span style="color: #F97583">==</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">    ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> lists[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">size_t</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">; i </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> lists.</span><span style="color: #B392F0">size</span><span style="color: #E1E4E8">(); i</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">    {</span></span>
<span class="line"><span style="color: #E1E4E8">        result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeTwoLists</span><span style="color: #E1E4E8">(result, lists[i]);</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> result;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>단순히 두 연결 리스트를 병합하는 함수를 이용하여 하나하나씩 병합하여 k - 1번 순회하여 모든 연결 리스트를 연결합니다.</p>
<h4 id="제출-결과">제출 결과</h4>
<p><img alt="Solution 1 result"  src="/asset_dir/result_1.9ad6e9b6_ZxuN7h.webp" width="1449" height="779" loading="lazy" decoding="async"></p>
<p>실행 속도는 296ms, 다른 C++ 제출자에 비해서 13% 정도의 성능밖에 나오지 않았습니다. 이에 대한 이유를 알기 위해 Big-O를 계산해보겠습니다.</p>
<p>각 연결리스트를 하나하나씩 더하기 때문에 <code>lists = {list_1, list_2, list_3 ... ,list_k}</code>가 있을 때, 각 리스트의 노드수의 평균을 n개라고 해보겠습니다.</p>
<p>그럼 처음 <code>merge(list_1, list_2)</code>를 수행할 때 O(n)의 시간 복잡도가 발생합니다(길이가 n인 리스트를 순회하므로). 그리고 반환된 리스트의 길이는 2n이 되겠죠. 이 리스트를 <code>list_1m2</code>라고 해보겠습니다.</p>
<p>그리고 <code>list_1m2</code>와 <code>list_3</code>에 대해서 <code>merge(list_1m2, list_3)</code>를 수행하면 O(2n)의 시간 복잡도가 발생합니다(길이가 2n, n인 리스트를 순회하므로 최악의 경우인 2n). 그럼 반환된 리스트 <code>list_1m3</code>은 길이가 3n이 됩니다.</p>
<p>이런식으로 k번째까지 쭉 더하면 발생하는 반복 횟수는 <code>n + 2n + 3n + ... + kn = n(1 + 2 + 3 + ... + k)</code>가 됩니다.</p>
<p>일반적으로 <code>1 + 2 + 3 + ... + k = k(k + 1)/2</code>로 계산할 수 있으니, <code>nk(k+1)/2</code>입니다. 따라서 O(kn^2)이 되게됩니다.</p>
<p>공간 복잡도는 입력 리스트에 관계 없이 하나의 포인터만 선언하므로 O(1)입니다.</p>
<details>
<summary>코드 전문</summary>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Solution</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #F97583">public:</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeKLists</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">vector</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8">></span><span style="color: #F97583">&#x26;</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">lists</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (lists.</span><span style="color: #B392F0">size</span><span style="color: #E1E4E8">() </span><span style="color: #F97583">==</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> lists[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">size_t</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">; i </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> lists.</span><span style="color: #B392F0">size</span><span style="color: #E1E4E8">(); i</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            result </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeTwoLists</span><span style="color: #E1E4E8">(result, lists[i]);</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> result;</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeTwoLists</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">list1</span><span style="color: #E1E4E8">, </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">list2</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">list1 </span><span style="color: #F97583">&#x26;&#x26;</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">!</span><span style="color: #E1E4E8">list2) </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">        </span></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> mergedHead </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> lastNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> node1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> list1;</span></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> node2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> list2;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">while</span><span style="color: #E1E4E8"> (node1 </span><span style="color: #F97583">&#x26;&#x26;</span><span style="color: #E1E4E8"> node2)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> selectedNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (node1->val </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> node2->val)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                selectedNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node1;</span></span>
<span class="line"><span style="color: #E1E4E8">                node1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node1->next;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">else</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                selectedNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node2;</span></span>
<span class="line"><span style="color: #E1E4E8">                node2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node2->next;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (mergedHead </span><span style="color: #F97583">==</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                mergedHead </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> selectedNode;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">else</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                lastNode->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> selectedNode;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">            lastNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> selectedNode;</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (node1)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">mergedHead)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                mergedHead </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node1;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">else</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node1; node </span><span style="color: #F97583">!=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">; node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node->next)</span></span>
<span class="line"><span style="color: #E1E4E8">                {</span></span>
<span class="line"><span style="color: #E1E4E8">                    lastNode->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node;</span></span>
<span class="line"><span style="color: #E1E4E8">                    lastNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node;</span></span>
<span class="line"><span style="color: #E1E4E8">                }</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (node2)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">mergedHead)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                mergedHead </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node2;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">else</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node2; node </span><span style="color: #F97583">!=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">; node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node->next)</span></span>
<span class="line"><span style="color: #E1E4E8">                {</span></span>
<span class="line"><span style="color: #E1E4E8">                    lastNode->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node;</span></span>
<span class="line"><span style="color: #E1E4E8">                    lastNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node;</span></span>
<span class="line"><span style="color: #E1E4E8">                }</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> mergedHead;   </span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
</details>
<h3 id="solution-2---prority-queue">Solution 2 - Prority Queue</h3>
<p>두 번째 풀이 방법은 우선 순위 큐, 혹은 Heap 자료 구조를 이용해 풀어보도록 하겠습니다.</p>
<p>우선 순위 큐(Heap)은 일반적으로 최대 혹은 최소 값을 빠르게 찾기 위해 사용되는 자료구조입니다.</p>
<p>현재 문제는 오름차순으로 정렬된 모든 리스트를 하나의 정렬된 리스트로 반환하는 문제이기 때문에 입력으로 주어진 모든 노드를 우선 순위 큐에 삽입하고 빼면서 하나의 리스트로 만든다면 문제를 해결할 수 있을것입니다.</p>
<p>풀이에 사용되는 언어가 C++이므로 C++ STL의 <a href="https://en.cppreference.com/w/cpp/container/priority_queue">priority_queue</a> 자료구조를 사용하도록 합니다. 해당 자료구조에 대한 자세한 스펙은 연결된 링크를 참조해주세요.</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> cmp </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [](</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">left</span><span style="color: #E1E4E8">, </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">right</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> left->val </span><span style="color: #F97583">></span><span style="color: #E1E4E8"> right->val;</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">priority_queue</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8">, </span><span style="color: #B392F0">vector</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8">>, </span><span style="color: #F97583">decltype</span><span style="color: #E1E4E8">(cmp)> </span><span style="color: #B392F0">queue</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">cmp</span><span style="color: #E1E4E8">);</span></span></code></pre>
<p>우선 순위 큐를 선언하고 별도의 비교 함수를 전달하여 해당 우선 순위 큐가 오름차순(min-heap)으로 형성되도록 합니다.</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">&#x26;&#x26;</span><span style="color: #E1E4E8">head : lists)</span></span>
<span class="line"><span style="color: #E1E4E8">{</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> head; node </span><span style="color: #F97583">!=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">; node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node->next)</span></span>
<span class="line"><span style="color: #E1E4E8">    {</span></span>
<span class="line"><span style="color: #E1E4E8">        queue.</span><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(node);</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>그리고 입력된 모든 노드를 큐에 삽입합니다.</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">while</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">queue.</span><span style="color: #B392F0">empty</span><span style="color: #E1E4E8">()) </span></span>
<span class="line"><span style="color: #E1E4E8">{</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> r </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> queue.</span><span style="color: #B392F0">top</span><span style="color: #E1E4E8">(); </span></span>
<span class="line"><span style="color: #E1E4E8">    queue.</span><span style="color: #B392F0">pop</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">head) </span></span>
<span class="line"><span style="color: #E1E4E8">    {</span></span>
<span class="line"><span style="color: #E1E4E8">        head </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> r;</span></span>
<span class="line"><span style="color: #E1E4E8">        tail </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> head;</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">continue</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">    tail->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> r;</span></span>
<span class="line"><span style="color: #E1E4E8">    r->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">    tail </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> r;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>그리고 단순히 큐에서 하나씩 pop을 수행하면서 하나의 연결 리스트로 형성합니다.</p>
<h4 id="제출-결과-1">제출 결과</h4>
<p><img alt="Solution 2 result"  src="/asset_dir/result_2.74c73a98_20p9Ct.webp" width="1439" height="792" loading="lazy" decoding="async"></p>
<p>실행 속도는 16ms, 97% 가량의 성능이 도출되었습니다.</p>
<p>우선 순위 큐에 경우 구현 방법에 따라 시간 복잡도가 약간씩 다르지만 보통 삽입은 O(1), 삭제는 O(logn)으로 도출됩니다. 따라서 k개의 리스트에 대해 삽입과 삭제를 하므로 O(klogn)로 계산할 수 있습니다.</p>
<p>다만, 공간 복잡도는 k개의 우선 순위 큐 공간이 필요하므로 O(k)가 되게됩니다.</p>
<details>
<summary>코드 전문</summary>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Solution</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #F97583">public:</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeKLists</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">vector</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8">></span><span style="color: #F97583">&#x26;</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">lists</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (lists.</span><span style="color: #B392F0">size</span><span style="color: #E1E4E8">() </span><span style="color: #F97583">==</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> head </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> tail </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> cmp </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> [](</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">left</span><span style="color: #E1E4E8">, </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">right</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> left->val </span><span style="color: #F97583">></span><span style="color: #E1E4E8"> right->val;</span></span>
<span class="line"><span style="color: #E1E4E8">        };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        priority_queue</span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8">, vector</span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8">ListNode</span><span style="color: #F97583">*></span><span style="color: #E1E4E8">, </span><span style="color: #F97583">decltype</span><span style="color: #E1E4E8">(cmp)</span><span style="color: #F97583">></span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">queue</span><span style="color: #E1E4E8">(cmp);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">&#x26;&#x26;</span><span style="color: #E1E4E8">head : lists)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> head; node </span><span style="color: #F97583">!=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">; node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node->next)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                queue.</span><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(node);</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">while</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">queue.</span><span style="color: #B392F0">empty</span><span style="color: #E1E4E8">()) </span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> r </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> queue.</span><span style="color: #B392F0">top</span><span style="color: #E1E4E8">(); </span></span>
<span class="line"><span style="color: #E1E4E8">            queue.</span><span style="color: #B392F0">pop</span><span style="color: #E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">head) </span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                head </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> r;</span></span>
<span class="line"><span style="color: #E1E4E8">                tail </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> head;</span></span>
<span class="line"><span style="color: #E1E4E8">                </span><span style="color: #F97583">continue</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">            tail->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> r;</span></span>
<span class="line"><span style="color: #E1E4E8">            r->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">            tail </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> r;</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> head;</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
</details>
<h3 id="solution-3---divide-and-conquer">Solution 3 - Divide and Conquer</h3>
<p>세 번째 방법은 분할 정복을 이용하여 성능은 최대한 유지하면서 공간 복잡도는 O(1)로 구현해보도록 하겠습니다.</p>
<p>구현 자체는 간단합니다. Solution 1과 동일하게 두 연결 리스트를 병합하는 함수를 이용합니다. 하지만, 병합하는 과정에서 분할 정복 기법을 이용하게 됩니다.</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> amount </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> lists.</span><span style="color: #B392F0">size</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> interval </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">while</span><span style="color: #E1E4E8"> (interval </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> amount)</span></span>
<span class="line"><span style="color: #E1E4E8">{</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">; i </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> amount </span><span style="color: #F97583">-</span><span style="color: #E1E4E8"> interval; i </span><span style="color: #F97583">+=</span><span style="color: #E1E4E8"> interval </span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">    {</span></span>
<span class="line"><span style="color: #E1E4E8">        lists[i] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeTwoLists</span><span style="color: #E1E4E8">(lists[i], lists[i </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> interval]);</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">    interval </span><span style="color: #F97583">*=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<h4 id="제출-결과-2">제출 결과</h4>
<p><img alt="Solution 3 result"  src="/asset_dir/result_3.a1bcba4c_Zr6cqL.webp" width="1430" height="781" loading="lazy" decoding="async">
실행 속도는 25ms로 Solution 2와 큰 차이가 없음을 확인할 수 있습니다.</p>
<p>공간 복잡도도 O(1)이기 때문에 시간 복잡도와 공간 복잡도를 아주 적절하게 Trade-off 한것입니다.</p>
<p>평균 노드 개수가 n인 k개의 연결 리스트를 분할 정복 기법으로 병합하는 경우의 Big-O를 계산해보겠습니다.</p>
<p><em>출처 : <a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&#x26;blogId=kks227&#x26;logNo=220776241154">https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&#x26;blogId=kks227&#x26;logNo=220776241154</a></em></p>
<p><img src="https://mblogthumb-phinf.pstatic.net/20160731_119/kks227_1469954954786CDXJ4_GIF/0721tree.gif?type=w2" alt="example"></p>
<p>분할 정복은 문제를 일반적으로 m개씩 분해합니다(여기서는 2개씩 분해합니다).</p>
<p>이때 우리의 코드는 k개의 연결 리스트를 2개씩 분할해서 병합합니다. 최대로 분할 될 수 있는 단계는 logk(밑이 2인데 생략)이므로 분할의 시간 복잡도는 O(logk)입니다.</p>
<p>이때 k개가 있으므로 O(klogk)로 계산할 수 있습니다. 그리고 n개의 노드를 병합해야 하므로 O(n * klogk)의 시간 복잡도가 계산됩니다.</p>
<p>Solution 1의 시간 복잡도는 <code>O(kn^2)</code>이였는데 Solution 3의 시간 복잡도는 <code>O(n * klogk)</code>이므로 당연히 더 빠르게 실행됩니다.</p>
<p>실제로 손으로 하나씩 계산해보더라도 Solution 1의 순회의 경우 n + 2n + 3n + …으로 병합한 두 연결 리스트의 결과인 2n에 대해서 또 병합을 하니 위와 같은 결과가 나오게 됩니다.</p>
<p>하지만 Solution 3의 경우 (n + n), (n + n)… (2n + 2n), (2n + 2n)… (4n + 4n), … 과 같이 분할된게 합쳐지면서 병합되기 때문에 최악의 경우가 nlogn밖에 되지 않습니다.</p>
<details>
<summary>코드 전문</summary>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Solution</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #F97583">public:</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeKLists</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">vector</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8">></span><span style="color: #F97583">&#x26;</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">lists</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (lists.</span><span style="color: #B392F0">size</span><span style="color: #E1E4E8">() </span><span style="color: #F97583">==</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> amount </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> lists.</span><span style="color: #B392F0">size</span><span style="color: #E1E4E8">();</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> interval </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">while</span><span style="color: #E1E4E8"> (interval </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> amount)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">; i </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> amount </span><span style="color: #F97583">-</span><span style="color: #E1E4E8"> interval; i </span><span style="color: #F97583">+=</span><span style="color: #E1E4E8"> interval </span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                lists[i] </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeTwoLists</span><span style="color: #E1E4E8">(lists[i], lists[i </span><span style="color: #F97583">+</span><span style="color: #E1E4E8"> interval]);</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            interval </span><span style="color: #F97583">*=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> lists[</span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">];</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">mergeTwoLists</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">list1</span><span style="color: #E1E4E8">, </span><span style="color: #B392F0">ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">list2</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">list1 </span><span style="color: #F97583">&#x26;&#x26;</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">!</span><span style="color: #E1E4E8">list2) </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">        </span></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> mergedHead </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> lastNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> node1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> list1;</span></span>
<span class="line"><span style="color: #E1E4E8">        ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> node2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> list2;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">while</span><span style="color: #E1E4E8"> (node1 </span><span style="color: #F97583">&#x26;&#x26;</span><span style="color: #E1E4E8"> node2)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            ListNode</span><span style="color: #F97583">*</span><span style="color: #E1E4E8"> selectedNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (node1->val </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> node2->val)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                selectedNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node1;</span></span>
<span class="line"><span style="color: #E1E4E8">                node1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node1->next;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">else</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                selectedNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node2;</span></span>
<span class="line"><span style="color: #E1E4E8">                node2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node2->next;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (mergedHead </span><span style="color: #F97583">==</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                mergedHead </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> selectedNode;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">else</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                lastNode->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> selectedNode;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">            lastNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> selectedNode;</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (node1)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">mergedHead)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                mergedHead </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node1;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">else</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node1; node </span><span style="color: #F97583">!=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">; node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node->next)</span></span>
<span class="line"><span style="color: #E1E4E8">                {</span></span>
<span class="line"><span style="color: #E1E4E8">                    lastNode->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node;</span></span>
<span class="line"><span style="color: #E1E4E8">                    lastNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node;</span></span>
<span class="line"><span style="color: #E1E4E8">                }</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (node2)</span></span>
<span class="line"><span style="color: #E1E4E8">        {</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">!</span><span style="color: #E1E4E8">mergedHead)</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                mergedHead </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node2;</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">            </span><span style="color: #F97583">else</span></span>
<span class="line"><span style="color: #E1E4E8">            {</span></span>
<span class="line"><span style="color: #E1E4E8">                </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">auto</span><span style="color: #E1E4E8"> node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node2; node </span><span style="color: #F97583">!=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">nullptr</span><span style="color: #E1E4E8">; node </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node->next)</span></span>
<span class="line"><span style="color: #E1E4E8">                {</span></span>
<span class="line"><span style="color: #E1E4E8">                    lastNode->next </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node;</span></span>
<span class="line"><span style="color: #E1E4E8">                    lastNode </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> node;</span></span>
<span class="line"><span style="color: #E1E4E8">                }</span></span>
<span class="line"><span style="color: #E1E4E8">            }</span></span>
<span class="line"><span style="color: #E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">        </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> mergedHead;   </span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
</details></div></article><p class="mt-6 font-bold"><a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a><span>&nbsp;시리즈의 다른 게시물 보기</span></p><div class="
            w-full flex flex-col space-y-4 mt-6 
            md:flex-row md:justify-between md:space-y-0
        "><a class="
                bg-gradient-to-l from-sky-300 from-50% to-white to-50% hover:bg-right transition-all ease-out duration-500 delay-100 
                flex justify-between items-center 
                rounded-xl ring-1 ring-offset-2 border ring-sky-300 
                font-bold p-4
                md:w-1/2 md:mr-6
                lg:w-2/3 xl:w-1/3
            " style="background-size: 200%;" href="/posts/leetcode---22-generate-parentheses"><span class="mr-10"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><g transform="rotate(180 14 14)"><path fill="currentColor" d="M15.705 4.289a1 1 0 1 0-1.406 1.422L21.675 13H4a1 1 0 1 0 0 2h17.673l-7.374 7.286a1 1 0 0 0 1.406 1.423l8.927-8.821a1.25 1.25 0 0 0 0-1.778l-8.927-8.821Z"></path></g></svg></span><span class="text-right truncate">LeetCode - 22. Generate Parentheses</span></a><a class="
                bg-gradient-to-l from-white from-50% to-sky-300 to-50% bg-right hover:bg-left transition-all ease-out delay-100 duration-500 
                flex justify-between items-center 
                rounded-xl ring-1 ring-offset-2 border ring-sky-300 
                font-bold p-4
                md:w-1/2 md:ml-6
                lg:w-2/3 xl:w-1/3
            " style="background-size: 200%;" href="/posts/leetcode---24-swap-nodes-in-pairs"><span class="text-left truncate">LeetCode - 24. Swap Nodes in Pairs</span><span class="text-right ml-10"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill="currentColor" d="M15.705 4.289a1 1 0 1 0-1.406 1.422L21.675 13H4a1 1 0 1 0 0 2h17.673l-7.374 7.286a1 1 0 0 0 1.406 1.423l8.927-8.821a1.25 1.25 0 0 0 0-1.778l-8.927-8.821Z"></path></svg></span></a></div></div></main><footer class="w-full border-t-2 p-4"><p class="">Copyright 2023 by Jaehee All rights reserved.</p></footer></body></html>