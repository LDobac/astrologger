<!DOCTYPE html><html> <head><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="sitemap" href="/sitemap-index.xml"><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Astro v4.9.2"><meta name="description" content="정렬된 K개의 연결 리스트를 모두 하나의 연결 리스트로 합쳐야합니다."><meta name="author" content="jaehee"><meta property="og:url" content="https://jaehee.dev/posts/leetcode---23-merge-k-sorted-lists/"><meta property="og:type" content="website"><meta property="og:title" content="LeetCode - 23. Merge k Sorted Lists">
            <meta property="og:description" content="정렬된 K개의 연결 리스트를 모두 하나의 연결 리스트로 합쳐야합니다."><meta property="og:image" content="https://jaehee.dev/posts/leetcode---23-merge-k-sorted-lists.png"><meta property="og:image:alt" content="Thumbnail of LeetCode - 23. Merge k Sorted Lists"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-BLG37NTK4J"></script>
            <script>
                // @ts-expect-error
                window.dataLayer = window.dataLayer || [];
                // @ts-expect-error
                function gtag(){dataLayer.push(arguments);}
                // @ts-expect-error
                gtag('js', new Date());
                // @ts-expect-error
                gtag('config', 'G-BLG37NTK4J');
            </script><!-- Naver Search Advisor --><meta name="naver-site-verification" content="6d6d37b7cb8c33fa22601afa3a994e0526b4a43f"><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"><title>LeetCode - 23. Merge k Sorted Lists</title><link rel="stylesheet" href="/asset_dir/index.CPsGRSeE.css">
<link rel="stylesheet" href="/asset_dir/index.Do-U5qY0.css"><script type="module" src="/asset_dir/hoisted.DZL4CV8D.js"></script></head> <body class="w-full"> <header class="flex flex-col w-full justify-center items-center mt-6"> <a href="/"> <img src="/asset_dir/profile_image.g0VlSnMI_Z1olwg2.webp" class="rounded-full w-28" alt="Profile image with cat" width="200" height="200" loading="lazy" decoding="async"> <p class="mt-1 text-3xl font-bold hover:text-sky-300">Jaehee</p> </a> <p class="mt-1">Hi!</p> <nav class="content-container border-y py-4 mt-6"> <ul class="w-full flex justify-between px-6 font-bold"> <li class="hover:text-sky-300"><a href="/posts/1">Posts</a></li> <li class="hover:text-sky-300"><a href="https://ljhblog.tistory.com/">Tistory</a></li> <li class="hover:text-sky-300"><a href="https://github.com/LDobac">Github</a></li> <li class="hover:text-sky-300"><a href="https://www.instagram.com/jaehee24_/">Instagram</a></li> <li class="hover:text-sky-300"><a href="/portfolio">Portfolio</a></li> </ul> </nav> </header> <main>    <div class="content-container my-6 px-4"> <header class="flex flex-col space-y-4 border-b-2 border-sky-300 pb-6"> <img src="/posts/leetcode---23-merge-k-sorted-lists.png" class="w-full bg-black" alt="Thumbnail of LeetCode - 23. Merge k Sorted Lists" width="1200" height="630" loading="lazy" decoding="async"> <h1 class="leading-none"> <span class="block text-2xl font-bold">LeetCode - 23. Merge k Sorted Lists</span> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </h1> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/hard/1"> <span>hard</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> <p> <span>작성일 : 2021년 12월 08일</span> <span>&nbsp;/&nbsp;수정일 : 2024년 06월 06일</span> </p> </header> <article class="mt-6 border-b-2 border-sky-300 pb-6"> <div class="markdown-body"> <h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%AC%B8%EC%A0%9C-%EA%B0%9C%EC%9A%94">문제 개요</a></li>
<li><a href="#%ED%92%80%EC%9D%B4">풀이</a>
<ol>
<li><a href="#solution-1---merge-one-by-one">Solution 1 - Merge one by one</a>
<ol>
<li><a href="#%EC%A0%9C%EC%B6%9C-%EA%B2%B0%EA%B3%BC">제출 결과</a></li>
</ol>
</li>
<li><a href="#solution-2---prority-queue">Solution 2 - Prority Queue</a>
<ol>
<li><a href="#%EC%A0%9C%EC%B6%9C-%EA%B2%B0%EA%B3%BC-1">제출 결과</a></li>
</ol>
</li>
<li><a href="#solution-3---divide-and-conquer">Solution 3 - Divide and Conquer</a>
<ol>
<li><a href="#%EC%A0%9C%EC%B6%9C-%EA%B2%B0%EA%B3%BC-2">제출 결과</a></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="문제-개요">문제 개요</h2>
<p>난이도 - <code>HARD</code> 사용 언어 - <code>C++</code></p>
<p>지난 <a href="https://jaehee.dev/posts/leetcode---21-merge-two-sorted-lists/">LeetCode - 21. Merge Two Sorted Lists</a> 문제의 확장 버전입니다.</p>
<p>정렬된 k개의 연결 리스트가 입력되면 모든 연결 리스트를 정렬된 하나의 연결리스트 반환합니다.</p>
<p>문제 - <a href="https://leetcode.com/problems/merge-k-sorted-lists/">LeetCode - 23. Merge k Sorted Lists</a></p>
<h2 id="풀이">풀이</h2>
<p><a href="https://github.com/LDobac/leetcode/tree/master/23.%20Merge%20k%20Sorted%20Lists">My Solutions(Github)</a></p>
<h3 id="solution-1---merge-one-by-one">Solution 1 - Merge one by one</h3>
<p>첫 번째 해결 방법은 <a href="https://jaehee.dev/posts/leetcode---21-merge-two-sorted-lists/">LeetCode - 21. Merge Two Sorted Lists</a>의 풀이 방법을 그대로 사용하여 풀어보겠습니다.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#24292e;color:#e1e4e8" tabindex="0" data-language="cpp" data-theme="github-dark"><code data-language="cpp" data-theme="github-dark" style="display: grid;"><span data-line=""><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#B392F0"> mergeKLists</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">vector</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">></span><span style="color:#F97583">&#x26;</span><span style="color:#FFAB70"> lists</span><span style="color:#E1E4E8">) {</span></span>
<span data-line=""><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (lists.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">    ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lists[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">size_t</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> lists.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">(); i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">)</span></span>
<span data-line=""><span style="color:#E1E4E8">    {</span></span>
<span data-line=""><span style="color:#E1E4E8">        result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> mergeTwoLists</span><span style="color:#E1E4E8">(result, lists[i]);</span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> result;</span></span>
<span data-line=""><span style="color:#E1E4E8">}</span></span></code></pre></figure>
<p>단순히 두 연결 리스트를 병합하는 함수를 이용하여 하나하나씩 병합하여 k - 1번 순회하여 모든 연결 리스트를 연결합니다.</p>
<h4 id="제출-결과">제출 결과</h4>
<p><img  src="/asset_dir/result_1.CoQFbP03_ZxWQTd.webp" alt="Solution 1 result" width="1449" height="779" loading="lazy" decoding="async"></p>
<p>실행 속도는 296ms, 다른 C++ 제출자에 비해서 13% 정도의 성능밖에 나오지 않았습니다. 이에 대한 이유를 알기 위해 Big-O를 계산해보겠습니다.</p>
<p>각 연결리스트를 하나하나씩 더하기 때문에 <code>lists = {list_1, list_2, list_3 ... ,list_k}</code>가 있을 때, 각 리스트의 노드수의 평균을 n개라고 해보겠습니다.</p>
<p>그럼 처음 <code>merge(list_1, list_2)</code>를 수행할 때 O(n)의 시간 복잡도가 발생합니다(길이가 n인 리스트를 순회하므로). 그리고 반환된 리스트의 길이는 2n이 됩니다. 이 리스트를 <code>list_1m2</code>라고 해보겠습니다.</p>
<p>그리고 <code>list_1m2</code>와 <code>list_3</code>에 대해서 <code>merge(list_1m2, list_3)</code>를 수행하면 O(2n)의 시간 복잡도가 발생합니다(길이가 2n, n인 리스트를 순회하므로 최악의 경우인 2n). 그럼 반환된 리스트 <code>list_1m3</code>은 길이가 3n이 됩니다.</p>
<p>이런식으로 k번째까지 쭉 더하면 발생하는 반복 횟수는 <code>n + 2n + 3n + ... + kn = n(1 + 2 + 3 + ... + k)</code>가 됩니다.</p>
<p>일반적으로 <code>1 + 2 + 3 + ... + k = k(k + 1)/2</code>로 계산할 수 있으니, <code>nk(k+1)/2</code>입니다. 따라서 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(kn^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>이 되게됩니다.</p>
<p>공간 복잡도는 입력 리스트에 관계 없이 하나의 포인터만 선언하므로 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>입니다.</p>
<details>
<summary>코드 전문</summary>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#24292e;color:#e1e4e8" tabindex="0" data-language="cpp" data-theme="github-dark"><code data-line-numbers="" data-language="cpp" data-theme="github-dark" style="display: grid;" data-line-numbers-max-digits="2"><span data-line=""><span style="color:#F97583">class</span><span style="color:#B392F0"> Solution</span><span style="color:#E1E4E8"> {</span></span>
<span data-line=""><span style="color:#F97583">public:</span></span>
<span data-line=""><span style="color:#B392F0">    ListNode</span><span style="color:#F97583">*</span><span style="color:#B392F0"> mergeKLists</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">vector</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">></span><span style="color:#F97583">&#x26;</span><span style="color:#FFAB70"> lists</span><span style="color:#E1E4E8">) {</span></span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (lists.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lists[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">size_t</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> lists.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">(); i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#E1E4E8">            result </span><span style="color:#F97583">=</span><span style="color:#B392F0"> mergeTwoLists</span><span style="color:#E1E4E8">(result, lists[i]);</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> result;</span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#B392F0">    ListNode</span><span style="color:#F97583">*</span><span style="color:#B392F0"> mergeTwoLists</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> list1</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> list2</span><span style="color:#E1E4E8">) {</span></span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">list1 </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">list2) </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">        </span></span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> mergedHead </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> lastNode </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> node1 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> list1;</span></span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> node2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> list2;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        while</span><span style="color:#E1E4E8"> (node1 </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> node2)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#E1E4E8">            ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> selectedNode </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (node1->val </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> node2->val)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                selectedNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node1;</span></span>
<span data-line=""><span style="color:#E1E4E8">                node1 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node1->next;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#F97583">            else</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                selectedNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node2;</span></span>
<span data-line=""><span style="color:#E1E4E8">                node2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node2->next;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (mergedHead </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                mergedHead </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> selectedNode;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#F97583">            else</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                lastNode->next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> selectedNode;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">            lastNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> selectedNode;</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (node1)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">mergedHead)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                mergedHead </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node1;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#F97583">            else</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#F97583">                for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node1; node </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">; node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node->next)</span></span>
<span data-line=""><span style="color:#E1E4E8">                {</span></span>
<span data-line=""><span style="color:#E1E4E8">                    lastNode->next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node;</span></span>
<span data-line=""><span style="color:#E1E4E8">                    lastNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node;</span></span>
<span data-line=""><span style="color:#E1E4E8">                }</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (node2)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">mergedHead)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                mergedHead </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node2;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#F97583">            else</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#F97583">                for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node2; node </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">; node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node->next)</span></span>
<span data-line=""><span style="color:#E1E4E8">                {</span></span>
<span data-line=""><span style="color:#E1E4E8">                    lastNode->next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node;</span></span>
<span data-line=""><span style="color:#E1E4E8">                    lastNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node;</span></span>
<span data-line=""><span style="color:#E1E4E8">                }</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> mergedHead;   </span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""><span style="color:#E1E4E8">};</span></span></code></pre></figure>
</details>
<hr>
<h3 id="solution-2---prority-queue">Solution 2 - Prority Queue</h3>
<p>두 번째 풀이 방법은 우선 순위 큐, 혹은 Heap 자료 구조를 이용해 풀어보도록 하겠습니다.</p>
<p>우선 순위 큐(Heap)은 일반적으로 최대 혹은 최소 값을 빠르게 찾기 위해 사용되는 자료구조입니다.</p>
<p>현재 문제는 오름차순으로 정렬된 모든 리스트를 하나의 정렬된 리스트로 반환하는 문제이기 때문에 입력으로 주어진 모든 노드를 우선 순위 큐에 삽입하고 빼면서 하나의 리스트로 만든다면 문제를 해결할 수 있을것입니다.</p>
<p>풀이에 사용되는 언어가 C++이므로 C++ STL의 <a href="https://en.cppreference.com/w/cpp/container/priority_queue">priority_queue</a> 자료구조를 사용하도록 합니다. 해당 자료구조에 대한 자세한 스펙은 연결된 링크를 참조해주세요.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#24292e;color:#e1e4e8" tabindex="0" data-language="cpp" data-theme="github-dark"><code data-language="cpp" data-theme="github-dark" style="display: grid;"><span data-line=""><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> cmp </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [](</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> left</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> right</span><span style="color:#E1E4E8">) {</span></span>
<span data-line=""><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> left->val </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> right->val;</span></span>
<span data-line=""><span style="color:#E1E4E8">};</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#B392F0">priority_queue</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">vector</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">>, </span><span style="color:#F97583">decltype</span><span style="color:#E1E4E8">(cmp)> </span><span style="color:#B392F0">queue</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">cmp</span><span style="color:#E1E4E8">);</span></span></code></pre></figure>
<p>우선 순위 큐를 선언하고 별도의 비교 함수를 전달하여 해당 우선 순위 큐가 오름차순(min-heap)으로 형성되도록 합니다.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#24292e;color:#e1e4e8" tabindex="0" data-language="cpp" data-theme="github-dark"><code data-language="cpp" data-theme="github-dark" style="display: grid;"><span data-line=""><span style="color:#F97583">for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#E1E4E8">head : lists)</span></span>
<span data-line=""><span style="color:#E1E4E8">{</span></span>
<span data-line=""><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> head; node </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">; node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node->next)</span></span>
<span data-line=""><span style="color:#E1E4E8">    {</span></span>
<span data-line=""><span style="color:#E1E4E8">        queue.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(node);</span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""><span style="color:#E1E4E8">}</span></span></code></pre></figure>
<p>그리고 입력된 모든 노드를 큐에 삽입합니다.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#24292e;color:#e1e4e8" tabindex="0" data-language="cpp" data-theme="github-dark"><code data-language="cpp" data-theme="github-dark" style="display: grid;"><span data-line=""><span style="color:#F97583">while</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">queue.</span><span style="color:#B392F0">empty</span><span style="color:#E1E4E8">()) </span></span>
<span data-line=""><span style="color:#E1E4E8">{</span></span>
<span data-line=""><span style="color:#F97583">    auto</span><span style="color:#E1E4E8"> r </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> queue.</span><span style="color:#B392F0">top</span><span style="color:#E1E4E8">(); </span></span>
<span data-line=""><span style="color:#E1E4E8">    queue.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">head) </span></span>
<span data-line=""><span style="color:#E1E4E8">    {</span></span>
<span data-line=""><span style="color:#E1E4E8">        head </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> r;</span></span>
<span data-line=""><span style="color:#E1E4E8">        tail </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> head;</span></span>
<span data-line=""><span style="color:#F97583">        continue</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">    tail->next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> r;</span></span>
<span data-line=""><span style="color:#E1E4E8">    r->next </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">    tail </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> r;</span></span>
<span data-line=""><span style="color:#E1E4E8">}</span></span></code></pre></figure>
<p>그리고 단순히 큐에서 하나씩 pop을 수행하면서 하나의 연결 리스트로 형성합니다.</p>
<h4 id="제출-결과-1">제출 결과</h4>
<p><img  src="/asset_dir/result_2.c4uAUHuM_1CPxTM.webp" alt="Solution 2 result" width="1439" height="792" loading="lazy" decoding="async"></p>
<p>실행 속도는 16ms, 97% 가량의 성능이 도출되었습니다.</p>
<p>우선 순위 큐에 경우 구현 방법에 따라 시간 복잡도가 약간씩 다르지만 보통 삽입은 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, 삭제는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>으로 도출됩니다. 따라서 k개의 리스트에 대해 삽입과 삭제를 하므로 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(klog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>로 계산할 수 있습니다.</p>
<p>다만, 공간 복잡도는 k개의 우선 순위 큐 공간이 필요하므로 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>가 되게됩니다.</p>
<details>
<summary>코드 전문</summary>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#24292e;color:#e1e4e8" tabindex="0" data-language="cpp" data-theme="github-dark"><code data-line-numbers="" data-language="cpp" data-theme="github-dark" style="display: grid;" data-line-numbers-max-digits="2"><span data-line=""><span style="color:#F97583">class</span><span style="color:#B392F0"> Solution</span><span style="color:#E1E4E8"> {</span></span>
<span data-line=""><span style="color:#F97583">public:</span></span>
<span data-line=""><span style="color:#B392F0">    ListNode</span><span style="color:#F97583">*</span><span style="color:#B392F0"> mergeKLists</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">vector</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">></span><span style="color:#F97583">&#x26;</span><span style="color:#FFAB70"> lists</span><span style="color:#E1E4E8">) {</span></span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (lists.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> head </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> tail </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        auto</span><span style="color:#E1E4E8"> cmp </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [](</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> left</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> right</span><span style="color:#E1E4E8">) {</span></span>
<span data-line=""><span style="color:#F97583">            return</span><span style="color:#E1E4E8"> left->val </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> right->val;</span></span>
<span data-line=""><span style="color:#E1E4E8">        };</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">        priority_queue</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8">ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">, vector</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8">ListNode</span><span style="color:#F97583">*></span><span style="color:#E1E4E8">, </span><span style="color:#F97583">decltype</span><span style="color:#E1E4E8">(cmp)</span><span style="color:#F97583">></span><span style="color:#B392F0"> queue</span><span style="color:#E1E4E8">(cmp);</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#E1E4E8">head : lists)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> head; node </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">; node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node->next)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                queue.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(node);</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        while</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">queue.</span><span style="color:#B392F0">empty</span><span style="color:#E1E4E8">()) </span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#F97583">            auto</span><span style="color:#E1E4E8"> r </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> queue.</span><span style="color:#B392F0">top</span><span style="color:#E1E4E8">(); </span></span>
<span data-line=""><span style="color:#E1E4E8">            queue.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">head) </span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                head </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> r;</span></span>
<span data-line=""><span style="color:#E1E4E8">                tail </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> head;</span></span>
<span data-line=""><span style="color:#F97583">                continue</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">            tail->next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> r;</span></span>
<span data-line=""><span style="color:#E1E4E8">            r->next </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">            tail </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> r;</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> head;</span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""><span style="color:#E1E4E8">};</span></span></code></pre></figure>
</details>
<hr>
<h3 id="solution-3---divide-and-conquer">Solution 3 - Divide and Conquer</h3>
<p>세 번째 방법은 분할 정복을 이용하여 성능은 최대한 유지하면서 공간 복잡도는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>로 구현해보도록 하겠습니다.</p>
<p>구현 자체는 간단합니다. Solution 1과 동일하게 두 연결 리스트를 병합하는 함수를 이용합니다. 하지만, 병합하는 과정에서 분할 정복 기법을 이용하게 됩니다.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#24292e;color:#e1e4e8" tabindex="0" data-language="cpp" data-theme="github-dark"><code data-language="cpp" data-theme="github-dark" style="display: grid;"><span data-line=""><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> amount </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lists.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">();</span></span>
<span data-line=""><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> interval </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#F97583">while</span><span style="color:#E1E4E8"> (interval </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> amount)</span></span>
<span data-line=""><span style="color:#E1E4E8">{</span></span>
<span data-line=""><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> amount </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> interval; i </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> interval </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">)</span></span>
<span data-line=""><span style="color:#E1E4E8">    {</span></span>
<span data-line=""><span style="color:#E1E4E8">        lists[i] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> mergeTwoLists</span><span style="color:#E1E4E8">(lists[i], lists[i </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> interval]);</span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""><span style="color:#E1E4E8">    interval </span><span style="color:#F97583">*=</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">}</span></span></code></pre></figure>
<h4 id="제출-결과-2">제출 결과</h4>
<p><img  src="/asset_dir/result_3.CgM3twrF_Z1YpCS1.webp" alt="Solution 3 result" width="1430" height="781" loading="lazy" decoding="async">
실행 속도는 25ms로 Solution 2와 큰 차이가 없음을 확인할 수 있습니다.</p>
<p>공간 복잡도도 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>이기 때문에 시간 복잡도와 공간 복잡도를 아주 적절하게 Trade-off 한것입니다.</p>
<p>평균 노드 개수가 n인 k개의 연결 리스트를 분할 정복 기법으로 병합하는 경우의 Big-O를 계산해보겠습니다.</p>
<p><em>출처 : <a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&#x26;blogId=kks227&#x26;logNo=220776241154">https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&#x26;blogId=kks227&#x26;logNo=220776241154</a></em></p>
<p><img src="https://mblogthumb-phinf.pstatic.net/20160731_119/kks227_1469954954786CDXJ4_GIF/0721tree.gif?type=w2" alt="example"></p>
<p>분할 정복은 문제를 일반적으로 m개씩 분해합니다(여기서는 2개씩 분해합니다).</p>
<p>이때 우리의 코드는 k개의 연결 리스트를 2개씩 분할해서 병합합니다. 최대로 분할 될 수 있는 단계는 logk(밑이 2인데 생략)이므로 분할의 시간 복잡도는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>입니다.</p>
<p>이때 k개가 있으므로 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(klogk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>로 계산할 수 있습니다. 그리고 n개의 노드를 병합해야 하므로 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n * klogk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>의 시간 복잡도가 계산됩니다.</p>
<p>Solution 1의 시간 복잡도는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(kn^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>이였는데 Solution 3의 시간 복잡도는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n * klogk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>이므로 당연히 더 빠르게 실행됩니다.</p>
<p>실제로 손으로 하나씩 계산해보더라도 Solution 1의 순회의 경우 n + 2n + 3n + …으로 병합한 두 연결 리스트의 결과인 2n에 대해서 또 병합을 하니 위와 같은 결과가 나오게 됩니다.</p>
<p>하지만 Solution 3의 경우 (n + n), (n + n)… (2n + 2n), (2n + 2n)… (4n + 4n), … 과 같이 분할된게 합쳐지면서 병합되기 때문에 최악의 경우가 nlogn밖에 되지 않습니다.</p>
<details>
<summary>코드 전문</summary>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#24292e;color:#e1e4e8" tabindex="0" data-language="cpp" data-theme="github-dark"><code data-line-numbers="" data-language="cpp" data-theme="github-dark" style="display: grid;" data-line-numbers-max-digits="2"><span data-line=""><span style="color:#F97583">class</span><span style="color:#B392F0"> Solution</span><span style="color:#E1E4E8"> {</span></span>
<span data-line=""><span style="color:#F97583">public:</span></span>
<span data-line=""><span style="color:#B392F0">    ListNode</span><span style="color:#F97583">*</span><span style="color:#B392F0"> mergeKLists</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">vector</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">></span><span style="color:#F97583">&#x26;</span><span style="color:#FFAB70"> lists</span><span style="color:#E1E4E8">) {</span></span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (lists.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        auto</span><span style="color:#E1E4E8"> amount </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lists.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">();</span></span>
<span data-line=""><span style="color:#F97583">        auto</span><span style="color:#E1E4E8"> interval </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#F97583">        while</span><span style="color:#E1E4E8"> (interval </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> amount)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> amount </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> interval; i </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> interval </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                lists[i] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> mergeTwoLists</span><span style="color:#E1E4E8">(lists[i], lists[i </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> interval]);</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#E1E4E8">            interval </span><span style="color:#F97583">*=</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> lists[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#B392F0">    ListNode</span><span style="color:#F97583">*</span><span style="color:#B392F0"> mergeTwoLists</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> list1</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">ListNode</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> list2</span><span style="color:#E1E4E8">) {</span></span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">list1 </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">list2) </span><span style="color:#F97583">return</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">        </span></span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> mergedHead </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> lastNode </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> node1 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> list1;</span></span>
<span data-line=""><span style="color:#E1E4E8">        ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> node2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> list2;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        while</span><span style="color:#E1E4E8"> (node1 </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> node2)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#E1E4E8">            ListNode</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> selectedNode </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (node1->val </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> node2->val)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                selectedNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node1;</span></span>
<span data-line=""><span style="color:#E1E4E8">                node1 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node1->next;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#F97583">            else</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                selectedNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node2;</span></span>
<span data-line=""><span style="color:#E1E4E8">                node2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node2->next;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (mergedHead </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                mergedHead </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> selectedNode;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#F97583">            else</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                lastNode->next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> selectedNode;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E1E4E8">            lastNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> selectedNode;</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (node1)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">mergedHead)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                mergedHead </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node1;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#F97583">            else</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#F97583">                for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node1; node </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">; node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node->next)</span></span>
<span data-line=""><span style="color:#E1E4E8">                {</span></span>
<span data-line=""><span style="color:#E1E4E8">                    lastNode->next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node;</span></span>
<span data-line=""><span style="color:#E1E4E8">                    lastNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node;</span></span>
<span data-line=""><span style="color:#E1E4E8">                }</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (node2)</span></span>
<span data-line=""><span style="color:#E1E4E8">        {</span></span>
<span data-line=""><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">mergedHead)</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#E1E4E8">                mergedHead </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node2;</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#F97583">            else</span></span>
<span data-line=""><span style="color:#E1E4E8">            {</span></span>
<span data-line=""><span style="color:#F97583">                for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">auto</span><span style="color:#E1E4E8"> node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node2; node </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> nullptr</span><span style="color:#E1E4E8">; node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node->next)</span></span>
<span data-line=""><span style="color:#E1E4E8">                {</span></span>
<span data-line=""><span style="color:#E1E4E8">                    lastNode->next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node;</span></span>
<span data-line=""><span style="color:#E1E4E8">                    lastNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> node;</span></span>
<span data-line=""><span style="color:#E1E4E8">                }</span></span>
<span data-line=""><span style="color:#E1E4E8">            }</span></span>
<span data-line=""><span style="color:#E1E4E8">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> mergedHead;   </span></span>
<span data-line=""><span style="color:#E1E4E8">    }</span></span>
<span data-line=""><span style="color:#E1E4E8">};</span></span></code></pre></figure>
</details> </div> </article> </div> <div class="mx-0 xl:mx-20 my-10 py-16 bg-neutral-100 shadow-inner"> <p class="font-bold text-2xl text-center space-y-4 mb-14"> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> <span>&nbsp;시리즈의 다른 게시물 보기</span> </p> <div class="content-container"> <div class="flex flex-col gap-6 items-center justify-center md:grid md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4"> <div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---24-swap-nodes-in-pairs"> <img src="/posts/leetcode---24-swap-nodes-in-pairs.png" class="rounded-xl object-cover bg-black" alt="Thumbnail of LeetCode - 24. Swap Nodes in Pairs" width="1200" height="630" loading="lazy" decoding="async"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---24-swap-nodes-in-pairs" class="block text-lg font-bold truncate mr-4">LeetCode - 24. Swap Nodes in Pairs</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 주어진 연결 리스트의 근접 노드와 짝을 지어 swap 합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/medium/1"> <span>medium</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 12월 09일</p> </div><div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---23-merge-k-sorted-lists"> <img src="/posts/leetcode---23-merge-k-sorted-lists.png" class="rounded-xl object-cover bg-black" alt="Thumbnail of LeetCode - 23. Merge k Sorted Lists" width="1200" height="630" loading="lazy" decoding="async"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---23-merge-k-sorted-lists" class="block text-lg font-bold truncate mr-4">LeetCode - 23. Merge k Sorted Lists</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 정렬된 K개의 연결 리스트를 모두 하나의 연결 리스트로 합쳐야합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/hard/1"> <span>hard</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 12월 08일</p> </div><div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---22-generate-parentheses"> <img src="/posts/leetcode---22-generate-parentheses.png" class="rounded-xl object-cover bg-black" alt="Thumbnail of LeetCode - 22. Generate Parentheses" width="1200" height="630" loading="lazy" decoding="async"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---22-generate-parentheses" class="block text-lg font-bold truncate mr-4">LeetCode - 22. Generate Parentheses</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 정수 N이 주어질 때 N개의 소괄호로 이뤄지는 모든 조합을 생성합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/medium/1"> <span>medium</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 12월 07일</p> </div><div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---21-merge-two-sorted-lists"> <img src="/posts/leetcode---21-merge-two-sorted-lists.png" class="rounded-xl object-cover bg-black" alt="Thumbnail of LeetCode - 21. Merge Two Sorted Lists" width="1200" height="630" loading="lazy" decoding="async"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---21-merge-two-sorted-lists" class="block text-lg font-bold truncate mr-4">LeetCode - 21. Merge Two Sorted Lists</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 정렬되어있는 두 연결 리스트를 하나로 합쳐야합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/easy/1"> <span>easy</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 12월 06일</p> </div><div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---20-valid-parentheses"> <img src="/posts/leetcode---20-valid-parentheses.png" class="rounded-xl object-cover bg-black" alt="Thumbnail of LeetCode - 20. Valid Parentheses" width="1200" height="630" loading="lazy" decoding="async"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---20-valid-parentheses" class="block text-lg font-bold truncate mr-4">LeetCode - 20. Valid Parentheses</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 주어진 문자열에서 열린 괄호과 닫힌 괄호가 올바르게 존재하는지 확인합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/easy/1"> <span>easy</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 12월 03일</p> </div> </div> </div> </div>   </main> <footer class="w-full border-t-2 p-4"> <div class="flex pb-2"> <svg class="w-[30px] h-[30px] mr-1"> <use  xlink:href="/asset_dir/cc-icons.CjibB2Sk.svg#cc-logo"></use> </svg> <svg class="w-[30px] h-[30px]"> <use  xlink:href="/asset_dir/cc-icons.CjibB2Sk.svg#cc-by"></use> </svg> </div> <p>본 블로그 내 저작권은
<a class="text-sky-300" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
KR에 따라 이용할 수 있습니다.(라이센스가 명시된 이미지/내용 등 제외.)
</p> <p>CC BY 4.0 KR에 따라 출처만 명시해주시면 상업적 이용, 공유, 복제 등 마음대로 이용할 수 있습니다.</p> </footer> </body></html>