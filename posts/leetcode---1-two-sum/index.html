<!DOCTYPE html><html> <head><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/asset_dir/ClientRouter.astro_astro_type_script_index_0_lang.CDGfc0hd.js"></script><link rel="sitemap" href="/sitemap-index.xml"><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Astro v5.16.8"><meta name="description" content="배열 내 두 숫자를 더하여 답을 만들 수 있는 배열의 원소를 찾아 인덱스를 반환해야 합니다."><meta name="author" content="jaehee"><meta property="og:url" content="https://jaehee.dev/posts/leetcode---1-two-sum/"><meta property="og:type" content="website"><meta property="og:title" content="LeetCode - 1. Two Sum">
            <meta property="og:description" content="배열 내 두 숫자를 더하여 답을 만들 수 있는 배열의 원소를 찾아 인덱스를 반환해야 합니다."><meta property="og:image" content="https://jaehee.dev/image/leetcode---1-two-sum.png"><meta property="og:image:alt" content="Thumbnail of LeetCode - 1. Two Sum"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-BLG37NTK4J"></script>
            <script>
                // @ts-expect-error
                window.dataLayer = window.dataLayer || [];
                // @ts-expect-error
                function gtag(){dataLayer.push(arguments);}
                // @ts-expect-error
                gtag('js', new Date());
                // @ts-expect-error
                gtag('config', 'G-BLG37NTK4J');
            </script><!-- Naver Search Advisor --><meta name="naver-site-verification" content="6d6d37b7cb8c33fa22601afa3a994e0526b4a43f"><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"><title>LeetCode - 1. Two Sum</title><link rel="stylesheet" href="/asset_dir/index.BSPJGQ1_.css">
<link rel="stylesheet" href="/asset_dir/index.BtwlEcOS.css"></head> <body class="w-full"> <header class="flex flex-col w-full justify-center items-center mt-6"> <a href="/"> <img src="/asset_dir/profile_image.g0VlSnMI_Z1olwg2.webp" alt="This is my cute cat." loading="eager" decoding="async" fetchpriority="auto" width="200" height="200" class="rounded-full w-28"> <p class="mt-1 text-3xl font-bold hover:text-sky-300">Jaehee</p> </a> <p class="mt-1">Hi!</p> <nav class="content-container border-y py-4 mt-6"> <ul class="w-full flex justify-between px-6 font-bold"> <li class="hover:text-sky-300"><a href="/posts/1">Posts</a></li> <li class="hover:text-sky-300"><a href="https://ljhblog.tistory.com/">Tistory</a></li> <li class="hover:text-sky-300"><a href="https://github.com/LDobac">Github</a></li> <li class="hover:text-sky-300"><a href="/portfolio">Portfolio</a></li> </ul> </nav> </header> <main>   <div class="content-container my-6 px-4"> <header class="flex flex-col space-y-4 border-b-2 border-sky-300 pb-6"> <img src="/image/leetcode---1-two-sum.png" alt="Thumbnail of LeetCode - 1. Two Sum" loading="lazy" decoding="async" fetchpriority="auto" width="1200" height="630" class="w-full bg-black"> <h1 class="leading-none"> <span class="block text-2xl font-bold">LeetCode - 1. Two Sum</span> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </h1> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/easy/1"> <span>easy</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> <p> <span>작성일 : 2021년 10월 24일</span> <span>&nbsp;/&nbsp;수정일 : 2023년 10월 10일</span> </p> </header> <article class="mt-6 border-b-2 border-sky-300 pb-6"> <div class="markdown-body"> <h2 id="목차">목차</h2>
<ol>
<li><a href="#%EB%AC%B8%EC%A0%9C-%EA%B0%9C%EC%9A%94">문제 개요</a>
<ol>
<li><a href="#%EC%98%88%EC%8B%9C">예시</a></li>
<li><a href="#%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4">제약조건</a></li>
</ol>
</li>
<li><a href="#%ED%92%80%EC%9D%B4">풀이</a>
<ol>
<li><a href="#solution-1---brute-force">Solution 1 - Brute force</a></li>
<li><a href="#solution-1---%EC%A0%9C%EC%B6%9C-%EA%B2%B0%EA%B3%BC">Solution 1 - 제출 결과</a></li>
<li><a href="#solution-2---hash-table">Solution 2 - Hash table</a></li>
<li><a href="#solution-2---%EC%A0%9C%EC%B6%9C-%EA%B2%B0%EA%B3%BC">Solution 2 - 제출 결과</a></li>
</ol>
</li>
</ol>
<h2 id="문제-개요">문제 개요</h2>
<p>난이도 - <code>EASY</code> 사용 언어 - <code>C++</code></p>
<p>입력값은 정수형 배열 <code>nums</code>와 정수형 <code>target</code>이 제공됩니다.
<code>nums</code>에서 두 숫자를 더해 <code>target</code>과 동일한 값이 나오는 배열 인덱스 두 개를 반환하면 됩니다.</p>
<p>문제 - <a href="https://leetcode.com/problems/two-sum/">LeetCode - 1. Two Sum</a></p>
<hr>
<h3 id="예시">예시</h3>
<p>입력 : <code>nums = [2,7,11,15]</code> <code>target = 9</code></p>
<p>출력 : <code>[0,1]</code></p>
<hr>
<h3 id="제약조건">제약조건</h3>
<ul>
<li>배열 내 같은 숫자는 <strong>재사용할 수 없다</strong>.</li>
<li>답은 <strong>정확히 하나</strong>만 존재한다.</li>
</ul>
<h2 id="풀이">풀이</h2>
<h3 id="solution-1---brute-force">Solution 1 - Brute force</h3>
<p>첫 번째로 떠올린 방법은 Brute force 즉, 무차별 대입 방법입니다.</p>
<p>이중 중첩 반복문을 통해 배열 내 두 숫자 <code>nums[x]</code>, <code>nums[y]</code>를 선택하여 더한 후 <code>target</code>과 동일한지 확인합니다.</p>
<p>만약 <code>target</code>과 동일하다면 두 수의 인덱스 <code>x</code>, <code>y</code>를 반환하며,
답이 없다면 빈 배열을 반환합니다.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#282c34;color:#abb2bf" tabindex="0" data-language="cpp" data-theme="one-dark-pro"><code data-line-numbers="" data-language="cpp" data-theme="one-dark-pro" style="display: grid;" data-line-numbers-max-digits="2"><span data-line=""><span style="color:#C678DD">for</span><span style="color:#ABB2BF"> (</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF"> x </span><span style="color:#C678DD">=</span><span style="color:#D19A66"> 0</span><span style="color:#ABB2BF"> ; x </span><span style="color:#C678DD">&#x3C;</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">size</span><span style="color:#ABB2BF">() ; x</span><span style="color:#C678DD">++</span><span style="color:#ABB2BF">) {</span></span>
<span data-line=""><span style="color:#C678DD">    for</span><span style="color:#ABB2BF"> (</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF"> y </span><span style="color:#C678DD">=</span><span style="color:#ABB2BF"> x </span><span style="color:#C678DD">+</span><span style="color:#D19A66"> 1</span><span style="color:#ABB2BF"> ; y </span><span style="color:#C678DD">&#x3C;</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">size</span><span style="color:#ABB2BF">() ; y</span><span style="color:#C678DD">++</span><span style="color:#ABB2BF">) {</span></span>
<span data-line=""><span style="color:#C678DD">        int</span><span style="color:#ABB2BF"> sumResult </span><span style="color:#C678DD">=</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">[x] </span><span style="color:#C678DD">+</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">[y];</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">        if</span><span style="color:#ABB2BF"> (target </span><span style="color:#C678DD">==</span><span style="color:#ABB2BF"> sumResult) {</span></span>
<span data-line=""><span style="color:#C678DD">            return</span><span style="color:#ABB2BF"> std::vector</span><span style="color:#C678DD">&#x3C;int></span><span style="color:#ABB2BF">{x, y};</span></span>
<span data-line=""><span style="color:#ABB2BF">        }</span></span>
<span data-line=""><span style="color:#ABB2BF">    }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">    return</span><span style="color:#ABB2BF"> std::</span><span style="color:#61AFEF">vector</span><span style="color:#ABB2BF">&#x3C;</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF">>();</span></span>
<span data-line=""><span style="color:#ABB2BF">}</span></span></code></pre></figure>
<p>정말 간단하게 배열 내 모든 원소를 순회하면서 <code>nums[x]</code>와 <code>nums[y]</code>를 선택합니다.</p>
<p>두 값의 덧셈을 <code>sumResult</code> 변수에 임시로 저장 후 <code>target</code>과 비교하여 정답인지 아닌지 찾습니다.</p>
<p>다만 특별한 점이라면 내부의 중첩된 반복문은 <code>x + 1</code>번째부터 시작합니다.
이러한 이유는 문제의 제약조건인 같은 수를 두 번 이상 사용하지 않기 위해서입니다.</p>
<p>만약 <code>x == y == 0</code>라면 <code>nums[0] + nums[0]</code>이므로 제약조건에 위배됩니다.</p>
<p>두 번째로 <code>2 + 4 == 4 + 2</code>의 경우도 제거하기 위해서입니다.</p>
<p><code>x = 1, y = 4</code>인경우 <code>nums[1] + nums[4]</code>는 <code>x = 4, y = 1</code>일경우 <code>nums[4] + nums[1]</code>과 동일하기에 불필요한 탐색입니다.</p>
<h3 id="solution-1---제출-결과">Solution 1 - 제출 결과</h3>
<p><img alt="Solution 1 result" loading="lazy" decoding="async" fetchpriority="auto" width="1437" height="791" src="/asset_dir/sol1_result.BGLUJ6sn_Z2qqetW.webp" ></p>
<p>실행 시간은 <code>463ms</code> 소요되었으며, 메모리는 <code>9.9MB</code> 사용되었습니다. 실행 시간 기준 하위 17% 정도에 위치하고 있습니다.</p>
<p>이중 중첩 반복문을 사용하고 있기에 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>의 실행 시간을 갖는 알고리즘입니다.</p>
<details>
<summary>코드 전문</summary>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#282c34;color:#abb2bf" tabindex="0" data-language="cpp" data-theme="one-dark-pro"><code data-line-numbers="" data-language="cpp" data-theme="one-dark-pro" style="display: grid;" data-line-numbers-max-digits="2"><span data-line=""><span style="color:#C678DD">#include</span><span style="color:#98C379"> &#x3C;vector></span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">class</span><span style="color:#E5C07B"> Solution</span></span>
<span data-line=""><span style="color:#ABB2BF">{</span></span>
<span data-line=""><span style="color:#C678DD">public:</span></span>
<span data-line=""><span style="color:#ABB2BF">    std::</span><span style="color:#E5C07B">vector</span><span style="color:#ABB2BF">&#x3C;</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF">> </span><span style="color:#61AFEF">Answer</span><span style="color:#ABB2BF">(std::</span><span style="color:#E5C07B">vector</span><span style="color:#ABB2BF">&#x3C;</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF">></span><span style="color:#C678DD">&#x26;</span><span style="color:#E06C75;font-style:italic"> nums</span><span style="color:#ABB2BF">, </span><span style="color:#C678DD">int</span><span style="color:#E06C75;font-style:italic"> target</span><span style="color:#ABB2BF">)</span></span>
<span data-line=""><span style="color:#ABB2BF">    {</span></span>
<span data-line=""><span style="color:#C678DD">        for</span><span style="color:#ABB2BF"> (</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF"> x </span><span style="color:#C678DD">=</span><span style="color:#D19A66"> 0</span><span style="color:#ABB2BF"> ; x </span><span style="color:#C678DD">&#x3C;</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">size</span><span style="color:#ABB2BF">() ; x</span><span style="color:#C678DD">++</span><span style="color:#ABB2BF">)</span></span>
<span data-line=""><span style="color:#ABB2BF">        {</span></span>
<span data-line=""><span style="color:#C678DD">            for</span><span style="color:#ABB2BF"> (</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF"> y </span><span style="color:#C678DD">=</span><span style="color:#ABB2BF"> x </span><span style="color:#C678DD">+</span><span style="color:#D19A66"> 1</span><span style="color:#ABB2BF"> ; y </span><span style="color:#C678DD">&#x3C;</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">size</span><span style="color:#ABB2BF">() ; y</span><span style="color:#C678DD">++</span><span style="color:#ABB2BF">)</span></span>
<span data-line=""><span style="color:#ABB2BF">            {</span></span>
<span data-line=""><span style="color:#C678DD">                int</span><span style="color:#ABB2BF"> sumResult </span><span style="color:#C678DD">=</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">[x] </span><span style="color:#C678DD">+</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">[y];</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">                if</span><span style="color:#ABB2BF"> (target </span><span style="color:#C678DD">==</span><span style="color:#ABB2BF"> sumResult)</span></span>
<span data-line=""><span style="color:#ABB2BF">                {</span></span>
<span data-line=""><span style="color:#C678DD">                    return</span><span style="color:#ABB2BF"> std::vector</span><span style="color:#C678DD">&#x3C;int></span><span style="color:#ABB2BF">{x, y};</span></span>
<span data-line=""><span style="color:#ABB2BF">                }</span></span>
<span data-line=""><span style="color:#ABB2BF">            }</span></span>
<span data-line=""><span style="color:#ABB2BF">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">        return</span><span style="color:#ABB2BF"> std::</span><span style="color:#61AFEF">vector</span><span style="color:#ABB2BF">&#x3C;</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF">>();</span></span>
<span data-line=""><span style="color:#ABB2BF">    }</span></span>
<span data-line=""><span style="color:#ABB2BF">};</span></span></code></pre></figure>
</details>
<hr>
<h3 id="solution-2---hash-table">Solution 2 - Hash table</h3>
<p><img alt="Follow-up" loading="lazy" decoding="async" fetchpriority="auto" width="702" height="35" src="/asset_dir/follow_up.CNTiigfk_1Ld4zq.webp" ></p>
<p><a href="#solution-1---brute-force">첫 번째 방법</a>은 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>의 실행 시간을 갖는 알고리즘입니다.
따라서 이보다 빠른 알고리즘을 찾을 필요가 있습니다.</p>
<p>첫 번째 방법이 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>의 실행 시간을 갖는 이유는 배열을 중첩 반복문에 배열을 n*n번 순회하기 때문입니다.
이러한 이유는<code>nums[0 ~ n] + nums[0 ~ n]</code>까지 모든 가능성을 테스트하기 때문에 n*n번의 순회가 필요하게 됩니다.</p>
<p>우린 이러한 탐색 과정을 최적화할 필요성이 있습니다.</p>
<p>현재 숫자를 찾을 때 <code>nums[x] + nums[y] = target</code>인 경우를 계속 탐색하고 있습니다.
이 연산을 조금 바꾸면 <code>target - nums[y] = nums[x]</code>가 됩니다.</p>
<p>그러므로 여기서 배열 내에 <code>target- nums[y]</code>에 대하여 <code>nums[x]</code> 값이 존재한다면 인덱스 <code>(x, y)</code>가 답이 될 것입니다.</p>
<p>만약 <code>nums[x]</code>가 배열 내에 없다면?
<code>target - nums[y + 1]</code>, <code>target - nums[y + 2]...</code> 인 경우에 대해서 탐색해야할 것 같습니다.</p>
<p>결국 똑같이 모든 경우를 탐색해야 하니 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>의 방법을 가지게 될까요?</p>
<p>이를 해결하기 위해 Hash Table이라는 저장 공간을 사용합니다. Hash Table은 <code>Key:Value</code> 형태의 자료구조입니다.</p>
<p>Map, Dictionary같은 자료구조와 비슷하지만,
Hash 함수를 이용해 인덱스를 생성하므로 삽입과 탐색이 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>로 정의되기에 탐색에서 큰 장점을 보이게 됩니다.</p>
<p>C++에서 Hash Table은 STL <a href="https://en.cppreference.com/w/cpp/container/unordered_map">unordered_map</a> container으로 제공되고 있습니다.</p>
<p>배열을 순회하면서 현재 원소의 값을 <code>Key</code>로 인덱스를 <code>Value</code>로 사용하여 Hash Table에 저장합니다.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#282c34;color:#abb2bf" tabindex="0" data-language="cpp" data-theme="one-dark-pro"><code data-language="cpp" data-theme="one-dark-pro" style="display: grid;"><span data-line=""><span style="color:#7F848E;font-style:italic">//                num, index</span></span>
<span data-line="" data-highlighted-line=""><span style="color:#ABB2BF">std::unordered_map</span><span style="color:#C678DD">&#x3C;int</span><span style="color:#ABB2BF">, </span><span style="color:#C678DD">int></span><span style="color:#ABB2BF"> table;</span></span>
<span data-line=""><span style="color:#ABB2BF">...</span></span>
<span data-line="" data-highlighted-line=""><span style="color:#E5C07B">table</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">insert</span><span style="color:#ABB2BF">(</span><span style="color:#E5C07B">std</span><span style="color:#ABB2BF">::</span><span style="color:#61AFEF">make_pair</span><span style="color:#ABB2BF">(</span><span style="color:#E5C07B">nums</span><span style="color:#ABB2BF">[x], x));</span></span></code></pre></figure>
<p>각 원소에 대해 <code>diff = target - nums[x]</code>,  <code>target</code>과의 차를 계산한 후 <code>diff</code>를 <code>Key</code>로 Hash Table에서 찾습니다.</p>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#282c34;color:#abb2bf" tabindex="0" data-language="cpp" data-theme="one-dark-pro"><code data-language="cpp" data-theme="one-dark-pro" style="display: grid;"><span data-line="" data-highlighted-line=""><span style="color:#C678DD">int</span><span style="color:#ABB2BF"> diff </span><span style="color:#C678DD">=</span><span style="color:#ABB2BF"> target </span><span style="color:#C678DD">-</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">[x];</span></span>
<span data-line=""> </span>
<span data-line="" data-highlighted-line=""><span style="color:#C678DD">auto</span><span style="color:#ABB2BF"> search </span><span style="color:#C678DD">=</span><span style="color:#E5C07B"> table</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">find</span><span style="color:#ABB2BF">(diff);</span></span>
<span data-line=""><span style="color:#C678DD">if</span><span style="color:#ABB2BF"> (search </span><span style="color:#C678DD">!=</span><span style="color:#E5C07B"> table</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">end</span><span style="color:#ABB2BF">()) {</span></span>
<span data-line=""><span style="color:#C678DD">    return</span><span style="color:#ABB2BF"> std::vector</span><span style="color:#C678DD">&#x3C;int></span><span style="color:#ABB2BF">{x, </span><span style="color:#E5C07B">search</span><span style="color:#ABB2BF">-></span><span style="color:#E06C75">second</span><span style="color:#ABB2BF">};</span></span>
<span data-line=""><span style="color:#ABB2BF">}</span></span></code></pre></figure>
<p>만약 Table내에 <code>diff</code>에 대한 <code>Key</code>가 존재한다면 배열 내에 <code>diff</code>와 똑같은 값을 가지는 원소가 존재한다는 의미입니다.</p>
<p>아까 Hash Table에 저장할 때 원소의 값을 <code>Key</code>, 인덱스를 <code>Value</code>에 저장했으므로 현재 반복문의 인덱스와 Hash Table에 저장된 인덱스를 반환하면 됩니다.</p>
<p>Hash Table의 삽입/탐색 속도는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>이고, 단일 반복문으로 배열을 n번 순회하므로 본 알고리즘은 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>의 실행 시간을 가지게 됩니다.</p>
<h3 id="solution-2---제출-결과">Solution 2 - 제출 결과</h3>
<p><img alt="Solution 2 result" loading="lazy" decoding="async" fetchpriority="auto" width="1437" height="783" src="/asset_dir/sol2_result.C_r3UpRh_VN70l.webp" ></p>
<p>기존의 약 <code>500ms</code>의 속도에서 <code>7ms</code>의 속도로 70배 가까이 향상되었습니다.</p>
<p>다만 별도의 저장 공간을 사용했기에 메모리의 크기가 <code>9.9MB</code>에서 <code>10.7MB</code>로 증가했습니다.</p>
<details>
<summary>코드 전문</summary>
<figure data-rehype-pretty-code-figure=""><pre style="background-color:#282c34;color:#abb2bf" tabindex="0" data-language="cpp" data-theme="one-dark-pro"><code data-line-numbers="" data-language="cpp" data-theme="one-dark-pro" style="display: grid;" data-line-numbers-max-digits="2"><span data-line=""><span style="color:#C678DD">#include</span><span style="color:#98C379"> &#x3C;vector></span></span>
<span data-line=""><span style="color:#C678DD">#include</span><span style="color:#98C379"> &#x3C;tuple></span></span>
<span data-line=""><span style="color:#C678DD">#include</span><span style="color:#98C379"> &#x3C;unordered_map></span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">class</span><span style="color:#E5C07B"> Solution</span></span>
<span data-line=""><span style="color:#ABB2BF">{</span></span>
<span data-line=""><span style="color:#C678DD">public:</span></span>
<span data-line=""><span style="color:#ABB2BF">    std::</span><span style="color:#E5C07B">vector</span><span style="color:#ABB2BF">&#x3C;</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF">> </span><span style="color:#61AFEF">Answer</span><span style="color:#ABB2BF">(std::</span><span style="color:#E5C07B">vector</span><span style="color:#ABB2BF">&#x3C;</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF">></span><span style="color:#C678DD">&#x26;</span><span style="color:#E06C75;font-style:italic"> nums</span><span style="color:#ABB2BF">, </span><span style="color:#C678DD">int</span><span style="color:#E06C75;font-style:italic"> target</span><span style="color:#ABB2BF">)</span></span>
<span data-line=""><span style="color:#ABB2BF">    {</span></span>
<span data-line=""><span style="color:#7F848E;font-style:italic">        //                num, index</span></span>
<span data-line=""><span style="color:#ABB2BF">        std::unordered_map</span><span style="color:#C678DD">&#x3C;int</span><span style="color:#ABB2BF">, </span><span style="color:#C678DD">int></span><span style="color:#ABB2BF"> table;</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">        for</span><span style="color:#ABB2BF"> (</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF"> x </span><span style="color:#C678DD">=</span><span style="color:#D19A66"> 0</span><span style="color:#ABB2BF"> ; x </span><span style="color:#C678DD">&#x3C;</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">size</span><span style="color:#ABB2BF">() ; x</span><span style="color:#C678DD">++</span><span style="color:#ABB2BF">)</span></span>
<span data-line=""><span style="color:#ABB2BF">        {</span></span>
<span data-line=""><span style="color:#C678DD">            int</span><span style="color:#ABB2BF"> diff </span><span style="color:#C678DD">=</span><span style="color:#ABB2BF"> target </span><span style="color:#C678DD">-</span><span style="color:#E5C07B"> nums</span><span style="color:#ABB2BF">[x];</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">            auto</span><span style="color:#ABB2BF"> search </span><span style="color:#C678DD">=</span><span style="color:#E5C07B"> table</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">find</span><span style="color:#ABB2BF">(diff);</span></span>
<span data-line=""><span style="color:#C678DD">            if</span><span style="color:#ABB2BF"> (search </span><span style="color:#C678DD">!=</span><span style="color:#E5C07B"> table</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">end</span><span style="color:#ABB2BF">())</span></span>
<span data-line=""><span style="color:#ABB2BF">            {</span></span>
<span data-line=""><span style="color:#C678DD">                return</span><span style="color:#ABB2BF"> std::vector</span><span style="color:#C678DD">&#x3C;int></span><span style="color:#ABB2BF">{x, </span><span style="color:#E5C07B">search</span><span style="color:#ABB2BF">-></span><span style="color:#E06C75">second</span><span style="color:#ABB2BF">};</span></span>
<span data-line=""><span style="color:#ABB2BF">            }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#E5C07B">            table</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">insert</span><span style="color:#ABB2BF">(</span><span style="color:#E5C07B">std</span><span style="color:#ABB2BF">::</span><span style="color:#61AFEF">make_pair</span><span style="color:#ABB2BF">(</span><span style="color:#E5C07B">nums</span><span style="color:#ABB2BF">[x], x));</span></span>
<span data-line=""><span style="color:#ABB2BF">        }</span></span>
<span data-line=""> </span>
<span data-line=""><span style="color:#C678DD">        return</span><span style="color:#ABB2BF"> std::</span><span style="color:#61AFEF">vector</span><span style="color:#ABB2BF">&#x3C;</span><span style="color:#C678DD">int</span><span style="color:#ABB2BF">>();</span></span>
<span data-line=""><span style="color:#ABB2BF">    }</span></span>
<span data-line=""><span style="color:#ABB2BF">};</span></span></code></pre></figure>
</details> </div> </article> </div> <div class="mx-0 xl:mx-20 my-10 py-16 bg-neutral-100 shadow-inner"> <div class="font-bold text-lg md:text-2xl text-center mb-14 px-4"> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> <div class="mt-2">시리즈의 다른 게시물 보기</div> </div> <div class="content-container px-4"> <div class="flex flex-col gap-6 items-center justify-center md:grid md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4"> <div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---5-longest-palindromic-substring"> <img src="/image/leetcode---5-longest-palindromic-substring.png" sizes="(min-width: 768px) 480px, 100vw" loading="lazy" decoding="async" alt="Thumbnail of LeetCode - 5. Longest Palindromic Substring" fetchpriority="auto" width="1200" height="630" class="rounded-xl object-cover bg-black"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---5-longest-palindromic-substring" class="block text-lg font-bold truncate mr-4">LeetCode - 5. Longest Palindromic Substring</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 주어진 문자열 중 가장 긴 회문(Palindrome)을 구합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/medium/1"> <span>medium</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 11월 06일</p> </div><div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---4-median-of-two-sorted-arrays"> <img src="/image/leetcode---4-median-of-two-sorted-arrays.png" sizes="(min-width: 768px) 480px, 100vw" loading="lazy" decoding="async" alt="Thumbnail of LeetCode - 4. Median of Two Sorted Arrays" fetchpriority="auto" width="1200" height="630" class="rounded-xl object-cover bg-black"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---4-median-of-two-sorted-arrays" class="block text-lg font-bold truncate mr-4">LeetCode - 4. Median of Two Sorted Arrays</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 정수 값이 담긴 두 정렬된 배열의 중앙값을 계산합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/hard/1"> <span>hard</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 10월 29일</p> </div><div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---3-longest-substring-without-repeating-characters"> <img src="/image/leetcode---3-longest-substring-without-repeating-characters.png" sizes="(min-width: 768px) 480px, 100vw" loading="lazy" decoding="async" alt="Thumbnail of LeetCode - 3. Longest Substring Without Repeating Characters" fetchpriority="auto" width="1200" height="630" class="rounded-xl object-cover bg-black"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---3-longest-substring-without-repeating-characters" class="block text-lg font-bold truncate mr-4">LeetCode - 3. Longest Substring Without Repeating Characters</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 문자열에서 똑같은 문자가 반복되지 않는, 가장 긴 부분 문자열을 찾아 반환해야 합니다. Sliding Window 기법과 C++ std::string_view를 이용해 가장 최적의 알고리즘을 작성해봅시다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/medium/1"> <span>medium</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 10월 27일</p> </div><div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---2-add-two-numbers"> <img src="/image/leetcode---2-add-two-numbers.png" sizes="(min-width: 768px) 480px, 100vw" loading="lazy" decoding="async" alt="Thumbnail of LeetCode - 2. Add Two Numbers" fetchpriority="auto" width="1200" height="630" class="rounded-xl object-cover bg-black"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---2-add-two-numbers" class="block text-lg font-bold truncate mr-4">LeetCode - 2. Add Two Numbers</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 연결 리스트로 표현되는 두 숫자를 더해 새로운 연결 리스트를 생성하여 반환해야 합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/medium/1"> <span>medium</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 10월 26일</p> </div><div class="flex flex-col pb-6 border-b-2 w-full"> <a href="/posts/leetcode---1-two-sum"> <img src="/image/leetcode---1-two-sum.png" sizes="(min-width: 768px) 480px, 100vw" loading="lazy" decoding="async" alt="Thumbnail of LeetCode - 1. Two Sum" fetchpriority="auto" width="1200" height="630" class="rounded-xl object-cover bg-black"> </a> <div class="mt-2 leading-none"> <a href="/posts/leetcode---1-two-sum" class="block text-lg font-bold truncate mr-4">LeetCode - 1. Two Sum</a> <a href="/series/leetcode/1" class="inline text-sky-300 hover:text-current transition">LeetCode</a> </div> <p class="mt-2 h-16 text-sm line-clamp-3"> 배열 내 두 숫자를 더하여 답을 만들 수 있는 배열의 원소를 찾아 인덱스를 반환해야 합니다. </p> <div class="mt-2"> <div class="flex flex-row flex-wrap w-full gap-3"> <a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/leetcode/1"> <span>LeetCode</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/easy/1"> <span>easy</span> </a><a class="px-2.5 py-1 text-sm rounded-2xl shadow-md hover:bg-sky-300 hover:text-white transition" href="/tags/c/1"> <span>C++</span> </a> </div> </div> <p class="text-sm text-gray-400 mt-2">2021년 10월 24일</p> </div> </div> </div> </div>   </main> <footer class="w-full border-t-2 p-4"> <div class="flex justify-between items-start"> <div class="flex flex-col text-left"> <p>본 블로그 내 저작권은
<a class="text-sky-300" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
KR에 따라 이용할 수 있습니다.(라이센스가 명시된 이미지/내용 등 제외.)
</p> <p>CC BY 4.0 KR에 따라 출처만 명시해주시면 상업적 이용, 공유, 복제 등 마음대로 이용할 수 있습니다.</p> </div> <div class="flex pb-2"> <svg class="w-[30px] h-[30px] mr-1"> <use  xlink:href="/asset_dir/cc-icons.BTtcxsIJ.svg#cc-logo"></use> </svg> <svg class="w-[30px] h-[30px]"> <use  xlink:href="/asset_dir/cc-icons.BTtcxsIJ.svg#cc-by"></use> </svg> </div> </div> </footer> </body></html>